var documenterSearchIndex = {"docs":
[{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"EditURL = \"https://github.com/sshin23/MadDiff.jl/blob/main/docs/src/guide.jl\"","category":"page"},{"location":"guide/#Getting-Started","page":"Quick Start","title":"Getting Started","text":"","category":"section"},{"location":"guide/#Automatic-Differentiation","page":"Quick Start","title":"Automatic Differentiation","text":"","category":"section"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"MadDiff provides a flexible user-interface for evaluating first/second-order derivatives of nonlinear expressions. In the following example, using MadDiff, we will create a function, gradient, and Hessian evaluator of the following function:","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"f(x) = x_1^2 + e^(x_2^p_1)2 + log(x_2x_3+p_2)","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"where x is the variable vector, and p is the parameter vector.","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"We first import MadDiff.","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"using MadDiff","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"First, we create a Source of Variable's.","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"x = Variable()","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"x","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"The Base.getindex! function is extended so that x[i] for any i creates an expression for x_i. For example,","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"x[2]","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"x[2]","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"We can do a similar thing for Parameter's.","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"p = Parameter()\np[1]","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"p[1]","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"Now, we create the nonlienar expression expression.","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"expr = x[1]^2 + exp(x[2]^p[1])/2 + log(x[2]*x[3]+p[2])","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"x[1]^2 + exp(x[2]^p[1])/2 + log(x[2]*x[3] + p[2])","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"The function evaluator of the above expression can be created by using MadDiff.function_evaluator as follows:","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"f = Evaluator(expr)","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"Evaluator:\nx[1]^2 + exp(x[2]^p[1])/2 + log(x[2]*x[3] + p[2])","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"Now for a given variable and parameter values, the function can be evaluated as follows.","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"x0 = [0.,0.5,1.5]\np0 = [2,0.5]\nf(x0,p0)","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"0.8651562596580804","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"The gradient evaluator can be created as follows:","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"y0 = similar(x0)\ng = GradientEvaluator(expr)\ng(y0,x0,p0)\ny0","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"3-element Vector{Float64}:\n 0.0\n 1.8420127083438709\n 0.4","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"The Hessian evaluator can be created as follows:","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"z0 = zeros(3,3)\nh = HessianEvaluator(expr)\nh(z0,x0,p0)\nz0","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"3×3 Matrix{Float64}:\n 2.0  0.0        0.0\n 0.0  0.486038   0.0\n 0.0  0.32      -0.16","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"Note that only lower-triangular entries are evaluated.","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"The evaluator can be constructed in a sparse format:","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"sh = SparseHessianEvaluator(expr);","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"The sparse coordinates are:","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"sh.sparsity","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"4-element Vector{Tuple{Int64, Int64}}:\n (1, 1)\n (2, 2)\n (3, 2)\n (3, 3)","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"The sparse Hessian can be evaluated as follows:","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"z1 = zeros(length(sh.sparsity))\nsh(z1,x0,p0)\nz1","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"4-element Vector{Float64}:\n  2.0\n  0.4860381250316117\n  0.31999999999999995\n -0.16000000000000003","category":"page"},{"location":"guide/#Nonlinear-Programming","page":"Quick Start","title":"Nonlinear Programming","text":"","category":"section"},{"location":"guide/#Built-in-API","page":"Quick Start","title":"Built-in API","text":"","category":"section"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"MadDiff provides a built-in API for creating nonlinear prgogramming models and allows solving the created models using NLP solvers (in particular, those that are interfaced with NLPModels, such as NLPModelsIpopt and MadNLP). We now use MadDiff's bulit-in API to model the following nonlinear program:","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"beginaligned\nmin_x_i_i=0^N sum_i=2^N  100(x_i-1^2-x_i)^2+(x_i-1-1)^2\ntextst   3x_i+1^3+2x_i+2-5+sin(x_i+1-x_i+2)sin(x_i+1+x_i+2)+4x_i+1-x_i e^x_i-x_i+1-3 = 0\nendaligned","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"We model the problem with:","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"N = 10000","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"10000","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"First, we create a MadDiffModel.","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"m = MadDiffModel()","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"MadDiffModel{Float64} (not instantiated).\n","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"The variables can be created as follows:","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"x = [variable(m; start = mod(i,2)==1 ? -1.2 : 1.) for i=1:N];","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"The objective can be set as follows:","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"objective(m, sum(100(x[i-1]^2-x[i])^2+(x[i-1]-1)^2 for i=2:N));","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"The constraints can be set as follows:","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"for i=1:N-2\n    constraint(m, 3x[i+1]^3+2*x[i+2]-5+sin(x[i+1]-x[i+2])sin(x[i+1]+x[i+2])+4x[i+1]-x[i]exp(x[i]-x[i+1])-3 == 0);\nend","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"The important last step is instantiating the model. This step must be taken before calling optimizers.","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"instantiate!(m)","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"MadDiffModel{Float64} (instantiated).\n  Problem name: Generic\n   All variables: ████████████████████ 10000  All constraints: ████████████████████ 9998  \n            free: ████████████████████ 10000             free: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     \n           lower: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                lower: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     \n           upper: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                upper: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     \n         low/upp: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0              low/upp: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     \n           fixed: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                fixed: ████████████████████ 9998  \n          infeas: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0               infeas: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     \n            nnzh: ( 99.96% sparsity)   19999           linear: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     \n                                                    nonlinear: ████████████████████ 9998  \n                                                         nnzj: ( 99.97% sparsity)   29994 \n\n  Counters:\n             obj: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                 grad: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                 cons: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     \n        cons_lin: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0             cons_nln: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                 jcon: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     \n           jgrad: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                  jac: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0              jac_lin: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     \n         jac_nln: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                jprod: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0            jprod_lin: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     \n       jprod_nln: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0               jtprod: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0           jtprod_lin: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     \n      jtprod_nln: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                 hess: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                hprod: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     \n           jhess: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0               jhprod: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     \n","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"To solve the problem with Ipopt,","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"using NLPModelsIpopt\nipopt(m);","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"\n******************************************************************************\nThis program contains Ipopt, a library for large-scale nonlinear optimization.\n Ipopt is released as open source code under the Eclipse Public License (EPL).\n         For more information visit https://github.com/coin-or/Ipopt\n******************************************************************************\n\nThis is Ipopt version 3.14.4, running with linear solver MUMPS 5.4.1.\n\nNumber of nonzeros in equality constraint Jacobian...:    29994\nNumber of nonzeros in inequality constraint Jacobian.:        0\nNumber of nonzeros in Lagrangian Hessian.............:    19999\n\nTotal number of variables............................:    10000\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:        0\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:     9998\nTotal number of inequality constraints...............:        0\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        0\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  2.5405160e+06 2.48e+01 2.73e+01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  1.3512419e+06 1.49e+01 8.27e+01  -1.0 2.20e+00    -  1.00e+00 1.00e+00f  1\n   2  1.5156131e+05 4.28e+00 1.36e+02  -1.0 1.43e+00    -  1.00e+00 1.00e+00f  1\n   3  6.6755024e+01 3.09e-01 2.18e+01  -1.0 5.63e-01    -  1.00e+00 1.00e+00f  1\n   4  6.2338933e+00 1.73e-02 8.47e-01  -1.0 2.10e-01    -  1.00e+00 1.00e+00h  1\n   5  6.2324586e+00 1.15e-05 8.16e-04  -1.7 3.35e-03    -  1.00e+00 1.00e+00h  1\n   6  6.2324586e+00 8.36e-12 7.97e-10  -5.7 2.00e-06    -  1.00e+00 1.00e+00h  1\n\nNumber of Iterations....: 6\n\n                                   (scaled)                 (unscaled)\nObjective...............:   7.8692659500479645e-01    6.2324586324379885e+00\nDual infeasibility......:   7.9743417331632266e-10    6.3156786526652763e-09\nConstraint violation....:   8.3555384833289281e-12    8.3555384833289281e-12\nVariable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00\nComplementarity.........:   0.0000000000000000e+00    0.0000000000000000e+00\nOverall NLP error.......:   7.9743417331632266e-10    6.3156786526652763e-09\n\n\nNumber of objective function evaluations             = 7\nNumber of objective gradient evaluations             = 7\nNumber of equality constraint evaluations            = 7\nNumber of inequality constraint evaluations          = 0\nNumber of equality constraint Jacobian evaluations   = 7\nNumber of inequality constraint Jacobian evaluations = 0\nNumber of Lagrangian Hessian evaluations             = 6\nTotal seconds in IPOPT                               = 1.829\n\nEXIT: Optimal Solution Found.\n","category":"page"},{"location":"guide/#MadDiff-as-an-AD-backend-of-JuMP","page":"Quick Start","title":"MadDiff as an AD backend of JuMP","text":"","category":"section"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"MadDiff can be used as an automatic differentiation backend of JuMP. The problem above can be modeled in JuMP and solved with Ipopt along with MadDiff","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"using JuMP, Ipopt\n\nm = JuMP.Model(Ipopt.Optimizer)\n\n@variable(m, x[i=1:N], start=mod(i,2)==1 ? -1.2 : 1.)\n@NLobjective(m, Min, sum(100(x[i-1]^2-x[i])^2+(x[i-1]-1)^2 for i=2:N))\n@NLconstraint(m, [i=1:N-2], 3x[i+1]^3+2*x[i+2]-5+sin(x[i+1]-x[i+2])sin(x[i+1]+x[i+2])+4x[i+1]-x[i]exp(x[i]-x[i+1])-3 == 0)\n\noptimize!(m; differentiation_backend = MadDiffAD())","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"This is Ipopt version 3.14.4, running with linear solver MUMPS 5.4.1.\n\nNumber of nonzeros in equality constraint Jacobian...:    29994\nNumber of nonzeros in inequality constraint Jacobian.:        0\nNumber of nonzeros in Lagrangian Hessian.............:    19999\n\nTotal number of variables............................:    10000\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:        0\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:     9998\nTotal number of inequality constraints...............:        0\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        0\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  2.5405160e+06 2.48e+01 2.73e+01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  1.3512419e+06 1.49e+01 8.27e+01  -1.0 2.20e+00    -  1.00e+00 1.00e+00f  1\n   2  1.5156131e+05 4.28e+00 1.36e+02  -1.0 1.43e+00    -  1.00e+00 1.00e+00f  1\n   3  6.6755024e+01 3.09e-01 2.18e+01  -1.0 5.63e-01    -  1.00e+00 1.00e+00f  1\n   4  6.2338933e+00 1.73e-02 8.47e-01  -1.0 2.10e-01    -  1.00e+00 1.00e+00h  1\n   5  6.2324586e+00 1.15e-05 8.16e-04  -1.7 3.35e-03    -  1.00e+00 1.00e+00h  1\n   6  6.2324586e+00 8.36e-12 7.97e-10  -5.7 2.00e-06    -  1.00e+00 1.00e+00h  1\n\nNumber of Iterations....: 6\n\n                                   (scaled)                 (unscaled)\nObjective...............:   7.8692659500479645e-01    6.2324586324379885e+00\nDual infeasibility......:   7.9743417331632266e-10    6.3156786526652763e-09\nConstraint violation....:   8.3555384833289281e-12    8.3555384833289281e-12\nVariable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00\nComplementarity.........:   0.0000000000000000e+00    0.0000000000000000e+00\nOverall NLP error.......:   7.9743417331632266e-10    6.3156786526652763e-09\n\n\nNumber of objective function evaluations             = 7\nNumber of objective gradient evaluations             = 7\nNumber of equality constraint evaluations            = 7\nNumber of inequality constraint evaluations          = 0\nNumber of equality constraint Jacobian evaluations   = 7\nNumber of inequality constraint Jacobian evaluations = 0\nNumber of Lagrangian Hessian evaluations             = 6\nTotal seconds in IPOPT                               = 1.976\n\nEXIT: Optimal Solution Found.\n","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"This page was generated using Literate.jl.","category":"page"},{"location":"core/#MadDiffCore","page":"MadDiffCore","title":"MadDiffCore","text":"","category":"section"},{"location":"core/","page":"MadDiffCore","title":"MadDiffCore","text":"Modules = [MadDiffCore]","category":"page"},{"location":"core/#MadDiffCore.MadDiffCore","page":"MadDiffCore","title":"MadDiffCore.MadDiffCore","text":"MadDiffCore\n\nCore algorithm for MadDiff.\n\n\n\n\n\n","category":"module"},{"location":"core/#MadDiffCore.AbstractExpression","page":"MadDiffCore","title":"MadDiffCore.AbstractExpression","text":"AbstractExpression{T <: AbstractFloat}\n\nAbstract type for expression, gradient, hessian, entry, and field evaluators.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Entry","page":"MadDiffCore","title":"MadDiffCore.Entry","text":"Entry{T <: AbstractFloat}\n\nAbstract type for entry evaluators.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Expression","page":"MadDiffCore","title":"MadDiffCore.Expression","text":"Expression{T <: AbstractFloat}\n\nAbstract type for expression evaluators.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Expression1","page":"MadDiffCore","title":"MadDiffCore.Expression1","text":"Expression1{T, F <: Function ,E <: Expression{T}}  <: Expression{T}\n\nExpression for univariate function\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Expression2","page":"MadDiffCore","title":"MadDiffCore.Expression2","text":"Expression2{T, F <: Function,E1, E2} <: Expression{T}\n\nExpression for bivariate function\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.ExpressionIfElse","page":"MadDiffCore","title":"MadDiffCore.ExpressionIfElse","text":"ExpressionIfElse{T,E0 <: Expression{T}, E1, E2} <: Expression{T}\n\nExpression for ifelse\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.ExpressionSum","page":"MadDiffCore","title":"MadDiffCore.ExpressionSum","text":"ExpressionSum{T, E <: Expression{T}, I} <: Expression{T}\n\nExpression for a summation of Expressions\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Field","page":"MadDiffCore","title":"MadDiffCore.Field","text":"Field{T <: AbstractFloat}\n\nAbstract type for field evaluators.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Gradient","page":"MadDiffCore","title":"MadDiffCore.Gradient","text":"Gradient{T <: AbstractFloat}\n\nAbstract type for gradient evaluators.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Gradient-2","page":"MadDiffCore","title":"MadDiffCore.Gradient","text":"Gradient(e :: Expression{T}) where T\n\nReturns the Gradient of an absraction e.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Gradient0","page":"MadDiffCore","title":"MadDiffCore.Gradient0","text":"Gradient0{T} <: Gradient{T}\n\nGradient of Variable.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Gradient1","page":"MadDiffCore","title":"MadDiffCore.Gradient1","text":"Gradient1{T, F, D1 <: Gradient} <: Gradient{T}\n\nGradient of Expression1.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Gradient2","page":"MadDiffCore","title":"MadDiffCore.Gradient2","text":"Gradient2{T, F,D1 <: Gradient,D2 <: Gradient} <: Gradient{T}\n\nGradient of Expression2.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Gradient2F1","page":"MadDiffCore","title":"MadDiffCore.Gradient2F1","text":"Gradient2F1{T, F, D1 <: Gradient, R<: Real} <: Gradient{T}\n\nGradient of Expression2 whose first argument is <: Real.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Gradient2F2","page":"MadDiffCore","title":"MadDiffCore.Gradient2F2","text":"Gradient2F2{T, F,D1 <: Gradient, R<: Real} <: Gradient{T}\n\nGradient of Expression2 whose second argument is <: Real.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.GradientIfElse","page":"MadDiffCore","title":"MadDiffCore.GradientIfElse","text":"GradientIfElse{T, G1, G2} <: Gradient{T}\n\nGradient of ExpressionIfElse\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.GradientNull","page":"MadDiffCore","title":"MadDiffCore.GradientNull","text":"GradientNull{T} <: Gradient{T}\n\nGradient of Parameter or Real.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.GradientSum","page":"MadDiffCore","title":"MadDiffCore.GradientSum","text":"GradientSum{T,D <: Gradient{T},I} <: Gradient{T}\n\nGradient of ExpressionSum.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Hessian","page":"MadDiffCore","title":"MadDiffCore.Hessian","text":"Hessian{T <: AbstractFloat}\n\nAbstract type for hessian evaluators.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Hessian02","page":"MadDiffCore","title":"MadDiffCore.Hessian02","text":"Hessian02{T,H11,H12,H21,H22} <: Hessian{T}\n\nHessian of `\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Hessian11","page":"MadDiffCore","title":"MadDiffCore.Hessian11","text":"Hessian11{T,F,H1,H11} <: Hessian{T}\n\nHessian of Expression1\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Hessian11F1","page":"MadDiffCore","title":"MadDiffCore.Hessian11F1","text":"Hessian11F1{T,F,H1,H11,R} <: Hessian{T}\n\nHessian of Expression2 whose first argument is <: Real.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Hessian11F2","page":"MadDiffCore","title":"MadDiffCore.Hessian11F2","text":"Hessian11F2{T,F,H1,H11,R} <: Hessian{T}\n\nHessian of Expression2 whose second argument is <: Real.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.HessianNull","page":"MadDiffCore","title":"MadDiffCore.HessianNull","text":"HessianNull{T} <: Hessian{T} end\n\nHessian of linear expressions (e.g., Variable, Expression2{T, typeof(*), Int64, Variable{T}} where T)\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Parameter","page":"MadDiffCore","title":"MadDiffCore.Parameter","text":"Parameter{T} <: Expression{T}\n\nExpression for parameters.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Parameter-Tuple{Int64}","page":"MadDiffCore","title":"MadDiffCore.Parameter","text":"Parameter(n::Int)\n\nReturns a Parameter{Float64} whose index is n\n\nExample\n\njulia> e = Parameter(3)\np[3]\njulia> non_caching_eval(e, [1.,2.,3.], [4.,5.,6.])\n6.0\n\n\n\n\n\n","category":"method"},{"location":"core/#MadDiffCore.Parameter-Union{Tuple{Int64}, Tuple{T}} where T","page":"MadDiffCore","title":"MadDiffCore.Parameter","text":"Parameter{T}(n::Int) where T\n\nReturns a Parameter{T} whose index is n.\n\n\n\n\n\n","category":"method"},{"location":"core/#MadDiffCore.Variable","page":"MadDiffCore","title":"MadDiffCore.Variable","text":"Variable{T} <: Expression{T}\n\nExpression for variables.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Variable-Tuple{Int64}","page":"MadDiffCore","title":"MadDiffCore.Variable","text":"Variable(n::Int)\n\nReturns a Variable{Float64} whose index is n\n\nExample\n\njulia> e = Variable(2)\nx[2]\njulia> non_caching_eval(e, [1.,2.,3.])\n2.0\n\n\n\n\n\n","category":"method"},{"location":"core/#MadDiffCore.Variable-Union{Tuple{Int64}, Tuple{T}} where T","page":"MadDiffCore","title":"MadDiffCore.Variable","text":"Variable{T}(n::Int) where T\n\nReturns a Variable{T} whose index is n.\n\n\n\n\n\n","category":"method"},{"location":"special/#MadDiffMOI","page":"MadDiffSpecialFunctions","title":"MadDiffMOI","text":"","category":"section"},{"location":"special/","page":"MadDiffSpecialFunctions","title":"MadDiffSpecialFunctions","text":"Modules = [MadDiffSpecialFunctions]","category":"page"},{"location":"models/#MadDiffModels","page":"MadDiffModels","title":"MadDiffModels","text":"","category":"section"},{"location":"models/","page":"MadDiffModels","title":"MadDiffModels","text":"Modules = [MadDiffModels]","category":"page"},{"location":"models/#MadDiffModels.MadDiffModels","page":"MadDiffModels","title":"MadDiffModels.MadDiffModels","text":"MadDiffModels\n\nMadDiffModels is a submodule of MadDiff. MadDiffModels allows modeling nonlinear optimization problem of the following form:\n\nminimize:   f(x)\nsubject to: xl ≤   x  ≤ xu\n            gl ≤ g(x) ≤ gu,\n\nwhere:\n\nx ∈ R^n is the decision variable.\nf : R^n -> R   is the objective function\ng : R^n -> R^m is the constraint mapping.\n\nThe model is constructed as an NLPModel (see https://github.com/JuliaSmoothOptimizers/NLPModels.jl), and can be solved with various NLP solvers such as:\n\nMadNLP (https://github.com/MadNLP/MadNLP.jl)\nIpopt (https://github.com/JuliaSmoothOptimizers/NLPModelsIpopt.jl)\nKnitro (https://github.com/JuliaSmoothOptimizers/NLPModelsKnitro.jl)\n\n\n\n\n\n","category":"module"},{"location":"models/#MadDiffModels.Constraint","page":"MadDiffModels","title":"MadDiffModels.Constraint","text":"Constraint\n\nA constraint index of MadDiffModel.\n\n\n\n\n\n","category":"type"},{"location":"models/#MadDiffModels.MadDiffModel","page":"MadDiffModels","title":"MadDiffModels.MadDiffModel","text":"MadDiffModel{T <: Real}\n\nA mathematical model of a nonlinaer program.\n\n\n\n\n\n","category":"type"},{"location":"models/#MadDiffModels.MadDiffModel-Tuple{}","page":"MadDiffModels","title":"MadDiffModels.MadDiffModel","text":"MadDiffModel()\n\nCreates an empty MadDiffModel{Float64}.\n\nExample m = MadDiffModel(linear_solver = \"ma27\")\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.MadDiffModel-Union{Tuple{}, Tuple{T}} where T","page":"MadDiffModels","title":"MadDiffModels.MadDiffModel","text":"MadDiffModel{T}()\n\nCreates an empty MadDiffModel{T}.\n\nExample m = MadDiffModel{Float32}()\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.ModelParameter","page":"MadDiffModels","title":"MadDiffModels.ModelParameter","text":"ModelParameter{T <: AbstractFloat} <: MadDiffCore.AbstractParameter{T}\n\nA model parameter of MadDiffModel.\n\n\n\n\n\n","category":"type"},{"location":"models/#MadDiffModels.ModelVariable","page":"MadDiffModels","title":"MadDiffModels.ModelVariable","text":"ModelVariable{T <: AbstractFloat} <: MadDiffCore.AbstractVariable{T}\n\nA model variable of MadDiffModel.\n\n\n\n\n\n","category":"type"},{"location":"models/#MadDiffModels.constraint-Tuple{MadDiffModel, Expression}","page":"MadDiffModels","title":"MadDiffModels.constraint","text":"constraint(m::MadDiffModel, e::MadDiffCore.Expression; lb=0., ub=0.)\n\nAdds a constraint to MadDiffModel. Example ``` m = MadDiffModel()\n\nx = [variable(m) for i=1:3] constraint(m, x[1]^2 + 2*sin(x[2]) - exp(x[3]) >= 0) constraint(m, x[1]^4+ x[2]^4 x[3]^4; lb = 0.1, ub = 1.)\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.dual-Tuple{MadDiffModels.Constraint}","page":"MadDiffModels","title":"MadDiffModels.dual","text":"dual(c::Constraint)\n\nRetrun the dual of constraint c.\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.instantiate!-Tuple{MadDiffModel}","page":"MadDiffModels","title":"MadDiffModels.instantiate!","text":"instantiate!(m::MadDiffModel; sparse = true)\n\nInstantiates the model m. The model must be instantiated before solving.\n\nExample\n\nusing MadDiff, NLPModelsIpopt\n\nm = MadDiffModel() \n\nx = [variable(m) for i=1:3]\nobjective(m, x[1]^2 + x[2]^2 + sin(x[3]))\nconstraint(m, 3x[2]^2 <= 1.)\n\ninstantiate!(m)\nipopt(m)\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.lower_bound-Tuple{MadDiffModels.Constraint}","page":"MadDiffModels","title":"MadDiffModels.lower_bound","text":"lower_bound(c::Constraint)\n\nRetrun the lower bound of constraint c.\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.lower_bound-Union{Tuple{MadDiffModels.ModelVariable{T}}, Tuple{T}} where T","page":"MadDiffModels","title":"MadDiffModels.lower_bound","text":"lower_bound(x::ModelVariable{T}) where T\n\nRetrun the lower bound of variable x.\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.objective-Tuple{MadDiffModel, Expression}","page":"MadDiffModels","title":"MadDiffModels.objective","text":"objective(m::MadDiffModel, e::MadDiffCore.Expression\n\nSets the objective function for MadDiffModel. Only minimization is supported. Example\n\nm = MadDiffModel()\n\nx = [variable(m) for i=1:3]\nobjective(m, x[1]^2 + x[2] + sin(x[3]))\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.parameter-Union{Tuple{T}, Tuple{MadDiffModel{T}, Any}} where T","page":"MadDiffModels","title":"MadDiffModels.parameter","text":"parameter(m::MadDiffModel{T}, val)\n\nCreates a parameter for MadDiffModel with value val. Example\n\nm = MadDiffModel()\n\np = parameter(m, 0.5)\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.set_lower_bound-Tuple{MadDiffModels.Constraint, Any}","page":"MadDiffModels","title":"MadDiffModels.set_lower_bound","text":"set_lower_bound(c::Constraint,val)\n\nSet the lower bound of constraint c to val.\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.set_lower_bound-Union{Tuple{T}, Tuple{MadDiffModels.ModelVariable{T}, Any}} where T","page":"MadDiffModels","title":"MadDiffModels.set_lower_bound","text":"set_lower_bound(x::ModelVariable{T},val) where T\n\nSet the lower bound of variable 'x' to val.\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.set_upper_bound-Tuple{MadDiffModels.Constraint, Any}","page":"MadDiffModels","title":"MadDiffModels.set_upper_bound","text":"set_upper_bound(c::Constraint,val)\n\nSet the upper bound of constraint c to val.\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.set_upper_bound-Union{Tuple{T}, Tuple{MadDiffModels.ModelVariable{T}, Any}} where T","page":"MadDiffModels","title":"MadDiffModels.set_upper_bound","text":"set_upper_bound(x::ModelVariable{T},val) where T\n\nSet the upper bound of variable 'x' to val.\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.setvalue-Union{Tuple{T}, Tuple{MadDiffModels.ModelParameter{T}, Any}} where T","page":"MadDiffModels","title":"MadDiffModels.setvalue","text":"setvalue(p::ModelParameter{T},val) where T\n\nSet the value of parameter 'p' to val.\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.setvalue-Union{Tuple{T}, Tuple{MadDiffModels.ModelVariable{T}, Any}} where T","page":"MadDiffModels","title":"MadDiffModels.setvalue","text":"setvalue(x::ModelVariable{T},val) where T\n\nSet the value of variable 'x' to val.\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.upper_bound-Tuple{MadDiffModels.Constraint}","page":"MadDiffModels","title":"MadDiffModels.upper_bound","text":"upper_bound(c::Constraint)\n\nRetrun the upper bound of constraint c.\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.upper_bound-Union{Tuple{MadDiffModels.ModelVariable{T}}, Tuple{T}} where T","page":"MadDiffModels","title":"MadDiffModels.upper_bound","text":"upper_bound(x::ModelVariable{T}) where T\n\nRetrun the upper bound of variable x.\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.value-Union{Tuple{MadDiffModels.ModelParameter{T}}, Tuple{T}} where T","page":"MadDiffModels","title":"MadDiffModels.value","text":"value(p::ModelParameter{T}) where T\n\nReturn the value of parameter p.\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.value-Union{Tuple{MadDiffModels.ModelVariable{T}}, Tuple{T}} where T","page":"MadDiffModels","title":"MadDiffModels.value","text":"value(x::ModelVariable{T}) where T\n\nReturn the value of variable x.\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.variable-Union{Tuple{MadDiffModel{T}}, Tuple{T}} where T","page":"MadDiffModels","title":"MadDiffModels.variable","text":"variable(m::MadDiffModel{T}; lb=-Inf, ub=Inf, start=0.)\n\nCreates a variable for MadDiffModel.\n\nExample\n\nm = MadDiffModel()\n\nx = variable(m; lb = -1, ub = 1, start = 0.5)\n\n\n\n\n\n","category":"method"},{"location":"models/#NLPModels.cons!-Tuple{MadDiffModel, AbstractVector{T} where T, AbstractVector{T} where T}","page":"MadDiffModels","title":"NLPModels.cons!","text":"NLPModels.cons!(m::MadDiffModel,x::AbstractVector,y::AbstractVector)\n\nEvaluate the constraints of m at x and store the result in the vector y. \n\n\n\n\n\n","category":"method"},{"location":"models/#NLPModels.get_ifix","page":"MadDiffModels","title":"NLPModels.get_ifix","text":"get_ifix(m::MadDiffModel)\n\nReturn the value ifix from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_ifree","page":"MadDiffModels","title":"NLPModels.get_ifree","text":"get_ifree(m::MadDiffModel)\n\nReturn the value ifree from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_iinf","page":"MadDiffModels","title":"NLPModels.get_iinf","text":"get_iinf(m::MadDiffModel)\n\nReturn the value iinf from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_ilow","page":"MadDiffModels","title":"NLPModels.get_ilow","text":"get_ilow(m::MadDiffModel)\n\nReturn the value ilow from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_irng","page":"MadDiffModels","title":"NLPModels.get_irng","text":"get_irng(m::MadDiffModel)\n\nReturn the value irng from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_islp","page":"MadDiffModels","title":"NLPModels.get_islp","text":"get_islp(m::MadDiffModel)\n\nReturn the value islp from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_iupp","page":"MadDiffModels","title":"NLPModels.get_iupp","text":"get_iupp(m::MadDiffModel)\n\nReturn the value iupp from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_jfix","page":"MadDiffModels","title":"NLPModels.get_jfix","text":"get_jfix(m::MadDiffModel)\n\nReturn the value jfix from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_jfree","page":"MadDiffModels","title":"NLPModels.get_jfree","text":"get_jfree(m::MadDiffModel)\n\nReturn the value jfree from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_jinf","page":"MadDiffModels","title":"NLPModels.get_jinf","text":"get_jinf(m::MadDiffModel)\n\nReturn the value jinf from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_jlow","page":"MadDiffModels","title":"NLPModels.get_jlow","text":"get_jlow(m::MadDiffModel)\n\nReturn the value jlow from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_jrng","page":"MadDiffModels","title":"NLPModels.get_jrng","text":"get_jrng(m::MadDiffModel)\n\nReturn the value jrng from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_jupp","page":"MadDiffModels","title":"NLPModels.get_jupp","text":"get_jupp(m::MadDiffModel)\n\nReturn the value jupp from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_lcon","page":"MadDiffModels","title":"NLPModels.get_lcon","text":"get_lcon(m::MadDiffModel)\n\nReturn the value lcon from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_lin","page":"MadDiffModels","title":"NLPModels.get_lin","text":"get_lin(m::MadDiffModel)\n\nReturn the value lin from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_lin_nnzj","page":"MadDiffModels","title":"NLPModels.get_lin_nnzj","text":"get_lin_nnzj(m::MadDiffModel)\n\nReturn the value lin_nnzj from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_lvar","page":"MadDiffModels","title":"NLPModels.get_lvar","text":"get_lvar(m::MadDiffModel)\n\nReturn the value lvar from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_minimize","page":"MadDiffModels","title":"NLPModels.get_minimize","text":"get_minimize(m::MadDiffModel)\n\nReturn the value minimize from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_name","page":"MadDiffModels","title":"NLPModels.get_name","text":"get_name(m::MadDiffModel)\n\nReturn the value name from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_ncon","page":"MadDiffModels","title":"NLPModels.get_ncon","text":"get_ncon(m::MadDiffModel)\n\nReturn the value ncon from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_nlin","page":"MadDiffModels","title":"NLPModels.get_nlin","text":"get_nlin(m::MadDiffModel)\n\nReturn the value nlin from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_nln","page":"MadDiffModels","title":"NLPModels.get_nln","text":"get_nln(m::MadDiffModel)\n\nReturn the value nln from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_nln_nnzj","page":"MadDiffModels","title":"NLPModels.get_nln_nnzj","text":"get_nln_nnzj(m::MadDiffModel)\n\nReturn the value nln_nnzj from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_nlvb","page":"MadDiffModels","title":"NLPModels.get_nlvb","text":"get_nlvb(m::MadDiffModel)\n\nReturn the value nlvb from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_nlvc","page":"MadDiffModels","title":"NLPModels.get_nlvc","text":"get_nlvc(m::MadDiffModel)\n\nReturn the value nlvc from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_nlvo","page":"MadDiffModels","title":"NLPModels.get_nlvo","text":"get_nlvo(m::MadDiffModel)\n\nReturn the value nlvo from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_nnln","page":"MadDiffModels","title":"NLPModels.get_nnln","text":"get_nnln(m::MadDiffModel)\n\nReturn the value nnln from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_nnzh","page":"MadDiffModels","title":"NLPModels.get_nnzh","text":"get_nnzh(m::MadDiffModel)\n\nReturn the value nnzh from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_nnzj","page":"MadDiffModels","title":"NLPModels.get_nnzj","text":"get_nnzj(m::MadDiffModel)\n\nReturn the value nnzj from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_nnzo","page":"MadDiffModels","title":"NLPModels.get_nnzo","text":"get_nnzo(m::MadDiffModel)\n\nReturn the value nnzo from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_nvar","page":"MadDiffModels","title":"NLPModels.get_nvar","text":"get_nvar(m::MadDiffModel)\n\nReturn the value nvar from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_ucon","page":"MadDiffModels","title":"NLPModels.get_ucon","text":"get_ucon(m::MadDiffModel)\n\nReturn the value ucon from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_uvar","page":"MadDiffModels","title":"NLPModels.get_uvar","text":"get_uvar(m::MadDiffModel)\n\nReturn the value uvar from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_x0","page":"MadDiffModels","title":"NLPModels.get_x0","text":"get_x0(m::MadDiffModel)\n\nReturn the value x0 from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_y0","page":"MadDiffModels","title":"NLPModels.get_y0","text":"get_y0(m::MadDiffModel)\n\nReturn the value y0 from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.grad!-Tuple{MadDiffModel, AbstractVector{T} where T, AbstractVector{T} where T}","page":"MadDiffModels","title":"NLPModels.grad!","text":"NLPModels.grad!(m::MadDiffModel,x::AbstractVector,y::AbstractVector)\n\nEvaluate the gradient of m at x and store the result in the vector y.\n\n\n\n\n\n","category":"method"},{"location":"models/#NLPModels.hess_coord!-Tuple{MadDiffModel, AbstractVector{T} where T, AbstractVector{T} where T, AbstractVector{T} where T}","page":"MadDiffModels","title":"NLPModels.hess_coord!","text":"NLPModels.hess_coord!(m::MadDiffModel,x::AbstractVector,lag::AbstractVector,z::AbstractVector; obj_weight = 1.0)\n\nEvaluate the Lagrangian Hessian of m at primal x, dual lag, and objective weight obj_weight and store the result in the vector zin sparse coordinate format.\n\n\n\n\n\n","category":"method"},{"location":"models/#NLPModels.hess_structure!-Union{Tuple{T}, Tuple{MadDiffModel, AbstractVector{T}, AbstractVector{T}}} where T","page":"MadDiffModels","title":"NLPModels.hess_structure!","text":"NLPModels.hess_structure!(m::MadDiffModel,I::AbstractVector{T},J::AbstractVector{T})\n\nEvaluate the structure of the Lagrangian Hessian and store the result in I and J in sparse coordinate format.\n\n\n\n\n\n","category":"method"},{"location":"models/#NLPModels.jac_coord!-Tuple{MadDiffModel, AbstractVector{T} where T, AbstractVector{T} where T}","page":"MadDiffModels","title":"NLPModels.jac_coord!","text":"NLPModels.jac_coord!(m::MadDiffModel,x::AbstractVector,J::AbstractVector)\n\nEvaluate the constraints Jacobian of m at x and store the result in the vector J in sparse coordinate format.\n\n\n\n\n\n","category":"method"},{"location":"models/#NLPModels.jac_structure!-Union{Tuple{T}, Tuple{MadDiffModel, AbstractVector{T}, AbstractVector{T}}} where T","page":"MadDiffModels","title":"NLPModels.jac_structure!","text":"NLPModels.jac_structure!(m::MadDiffModel,I::AbstractVector{T},J::AbstractVector{T})\n\nEvaluate the structure of the constraints Jacobian and store the result in I and J in sparse coordinate format.\n\n\n\n\n\n","category":"method"},{"location":"models/#NLPModels.obj-Tuple{MadDiffModel, AbstractVector{T} where T}","page":"MadDiffModels","title":"NLPModels.obj","text":"NLPModels.obj(m::MadDiffModel,x::AbstractVector)\n\nReturn the objective value of m at x.\n\n\n\n\n\n","category":"method"},{"location":"moi/#MadDiffMOI","page":"MadDiffMOI","title":"MadDiffMOI","text":"","category":"section"},{"location":"moi/","page":"MadDiffMOI","title":"MadDiffMOI","text":"Modules = [MadDiffMOI]","category":"page"},{"location":"moi/#MadDiffMOI.MadDiffMOI","page":"MadDiffMOI","title":"MadDiffMOI.MadDiffMOI","text":"MadDiffMOI\n\nMadDiffMOI is a submodule of MadDiff. MadDifMOI allows solving nonlinear optimization problems specified by MathOptInterface (https://github.com/jump-dev/JuMP.jl/tree/od/moi-nonlinear).\n\n\n\n\n\n","category":"module"},{"location":"moi/#MadDiffCore.Expression-Tuple{MathOptInterface.Nonlinear.Expression}","page":"MadDiffMOI","title":"MadDiffCore.Expression","text":"Expression(ex::MOI.Nonlinear.Expression; subex = nothing)\n\nCreate a MadDiff.Expression from MOI.Expression.\n\n\n\n\n\n","category":"method"},{"location":"moi/#MadDiffCore.SparseNLPCore-Tuple{MathOptInterface.Nonlinear.Model}","page":"MadDiffMOI","title":"MadDiffCore.SparseNLPCore","text":"MadDiffCore.SparseNLPCore(nlp_data::MOI.Nonlinear.Model)\n\nCreate MadDiffCore.SparseNLPCore from MOI.Nonlinear.Model.\n\n\n\n\n\n","category":"method"},{"location":"moi/#MadDiffMOI.MadDiffAD","page":"MadDiffMOI","title":"MadDiffMOI.MadDiffAD","text":"MadDiffAD() <: MOI.Nonlinear.AbstractAutomaticDifferentiation\n\nA differentiation backend for MathOptInterface based on MadDiff\n\n\n\n\n\n","category":"type"},{"location":"moi/#MadDiffMOI.MadDiffEvaluator","page":"MadDiffMOI","title":"MadDiffMOI.MadDiffEvaluator","text":"MadDiffEvaluator <: MOI.AbstractNLPEvaluator\n\nA type for callbacks for MathOptInterface's nonlinear model.\n\n\n\n\n\n","category":"type"},{"location":"moi/#MathOptInterface.NLPBlockData-Tuple{MadDiffMOI.MadDiffEvaluator}","page":"MadDiffMOI","title":"MathOptInterface.NLPBlockData","text":"MOI.NLPBlockData(evaluator::MadDiffEvaluator)\n\nCreate MOI.NLPBlockData from MadDiffEvaluator\n\n\n\n\n\n","category":"method"},{"location":"moi/#MathOptInterface.Nonlinear.Evaluator-Tuple{MathOptInterface.Nonlinear.Model, MadDiffAD, Vector{MathOptInterface.VariableIndex}}","page":"MadDiffMOI","title":"MathOptInterface.Nonlinear.Evaluator","text":"MOI.Nonlinear.Evaluator(model::MOI.Nonlinear.Model, ::MadDiffAD, ::Vector{MOI.VariableIndex})\n\nCreate a MOI.Nonlinear.Evaluator from MOI.Nonlinear.Model using MadDiff's AD capability.\n\n\n\n\n\n","category":"method"},{"location":"moi/#MathOptInterface.eval_constraint-Tuple{MadDiffMOI.MadDiffEvaluator, Any, Any}","page":"MadDiffMOI","title":"MathOptInterface.eval_constraint","text":"MOI.eval_constraint(evaluator::MadDiffEvaluator, g, x)\n\nEvaluate the gradient of evaluator at x and store the result in the vector g.\n\n\n\n\n\n","category":"method"},{"location":"moi/#MathOptInterface.eval_constraint_jacobian-Tuple{MadDiffMOI.MadDiffEvaluator, Any, Any}","page":"MadDiffMOI","title":"MathOptInterface.eval_constraint_jacobian","text":"MOI.eval_constraint_jacobian(evaluator::MadDiffEvaluator, J, x)\n\nEvaluate the constraints Jacobian of evaluator at x and store the result in the vector J in sparse coordinate format.\n\n\n\n\n\n","category":"method"},{"location":"moi/#MathOptInterface.eval_hessian_lagrangian-Tuple{MadDiffMOI.MadDiffEvaluator, Any, Any, Any, Any}","page":"MadDiffMOI","title":"MathOptInterface.eval_hessian_lagrangian","text":"MOI.eval_hessian_lagrangian(evaluator::MadDiffEvaluator, H, x, σ, μ)\n\nEvaluate the Lagrangian Hessian of evaluator at primal x, dual μ, and objective weight σ and store the result in the vector H in sparse coordinate format.\n\n\n\n\n\n","category":"method"},{"location":"moi/#MathOptInterface.eval_objective-Tuple{MadDiffMOI.MadDiffEvaluator, Any}","page":"MadDiffMOI","title":"MathOptInterface.eval_objective","text":"MOI.eval_objective(evaluator::MadDiffEvaluator, x)\n\nReturn the objective value of evaluator at x.\n\n\n\n\n\n","category":"method"},{"location":"moi/#MathOptInterface.eval_objective_gradient-Tuple{MadDiffMOI.MadDiffEvaluator, Any, Any}","page":"MadDiffMOI","title":"MathOptInterface.eval_objective_gradient","text":"MOI.eval_objective_gradient(evaluator::MadDiffEvaluator, g, x)\n\nEvaluate the constraints of evaluator at x and store the result in the vector g. \n\n\n\n\n\n","category":"method"},{"location":"moi/#MathOptInterface.hessian_lagrangian_structure-Tuple{MadDiffMOI.MadDiffEvaluator}","page":"MadDiffMOI","title":"MathOptInterface.hessian_lagrangian_structure","text":"MOI.hessian_lagrangian_structure(evaluator::MadDiffEvaluator)\n\nReturn the structure of the Lagrangian Hessian in Vector{Tuple{Int,Int}} format.\n\n\n\n\n\n","category":"method"},{"location":"moi/#MathOptInterface.jacobian_structure-Tuple{MadDiffMOI.MadDiffEvaluator}","page":"MadDiffMOI","title":"MathOptInterface.jacobian_structure","text":"MOI.jacobian_structure(evaluator::MadDiffEvaluator)\n\nReturn the structure of the constraints Jacobian in Vector{Tuple{Int,Int}} format.\n\n\n\n\n\n","category":"method"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Welcome to the documentation of MadDiff.jl","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Warning\nThis documentation page is under construction.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nThis documentation is also available in PDF format.","category":"page"},{"location":"#What-is-MadDiff?","page":"Introduction","title":"What is MadDiff?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"MadDiff.jl is a simple algebraic modeling/differentiation package. MadDiff.jl constructs first and second derivative functions off-line (i.e., prior to calling the optimization solver) by applying operator overloading-based automatic differentiation on functions. The exact derivative functions can be obtained as results. ","category":"page"},{"location":"#Bug-reports-and-support","page":"Introduction","title":"Bug reports and support","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Please report issues and feature requests via the Github issue tracker. ","category":"page"},{"location":"tutorial/","page":"How it Works","title":"How it Works","text":"EditURL = \"https://github.com/sshin23/MadDiff.jl/blob/main/docs/src/tutorial.jl\"","category":"page"},{"location":"tutorial/#How-it-Works","page":"How it Works","title":"How it Works","text":"","category":"section"},{"location":"tutorial/","page":"How it Works","title":"How it Works","text":"","category":"page"},{"location":"tutorial/","page":"How it Works","title":"How it Works","text":"This page was generated using Literate.jl.","category":"page"}]
}
