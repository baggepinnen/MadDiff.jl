var documenterSearchIndex = {"docs":
[{"location":"guide/#Nonlinear-Expressions","page":"Quick Start","title":"Nonlinear Expressions","text":"","category":"section"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"MadDiff.jl provides a flexible user-interface for writing nonlinear expressions and evaluating the expressions and functions. For example,","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"using MadDiff\n\nx = Variable()\np = Parameter()\nexpr = x[1]^2 + exp(x[2]^p[1])/2 + log(x[3]+p[2])\nprintln(expr) # x[1]^2 + exp(x[2]^p[1])/2 + log(x[3] + p[2])\n\nx0 = [0.,0.5,1.5]\np0 = [2,0.5]\n\nf = function_evaluator(expr)\nprintln(\"f(x0,p0) = $(f(x0,p0))\") # f(x0,p0) = 1.3351598889038159\n\ny0 = zeros(3)\ng = gradient_evaluator(expr)\ng(y0,x0,p0)\nprintln(\"g(x0,p0) = $y0\") # g(x0,p0) = [0.0, 0.6420127083438707, 0.5]","category":"page"},{"location":"guide/#Nonlinear-Programming","page":"Quick Start","title":"Nonlinear Programming","text":"","category":"section"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"MadDiff.jl provides a simple user-interface for creating nonlinear prgogramming models and allows solving the created models using the solvers with NLPModels.jl interface (such as NLPModelsIpopt.jl and MadNLP.jl). The syntax is as follows:","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"using MadDiff, NLPModelsIpopt\n\nm = MadDiffModel(; print_level=3) \n\nx = [variable(m; start=mod(i,2)==1 ? -1.2 : 1.) for i=1:1000]\nobjective(m, sum(100(x[i-1]^2-x[i])^2+(x[i-1]-1)^2 for i=2:1000))\nfor i=1:998\n    constraint(m, 3x[i+1]^3+2*x[i+2]-5+sin(x[i+1]-x[i+2])sin(x[i+1]+x[i+2])+4x[i+1]-x[i]exp(x[i]-x[i+1])-3 == 0)\nend\n\ninstantiate!(m) # this makes the model ready to be solved\nipopt(m)","category":"page"},{"location":"guide/#Use-with-JuMP","page":"Quick Start","title":"Use with JuMP","text":"","category":"section"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"MadDiff.jl can be used as an automatic differentiation backend. The syntax is as follows:","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"using MadDiff, JuMP, Ipopt\n\nm = JuMP.Model(Ipopt.Optimizer) \n\n@variable(m, x[i=1:1000], start=mod(i,2)==1 ? -1.2 : 1.)\n@NLobjective(m, Min, sum(100(x[i-1]^2-x[i])^2+(x[i-1]-1)^2 for i=2:1000))\n@NLconstraint(m, [i=1:998], 3x[i+1]^3+2*x[i+2]-5+sin(x[i+1]-x[i+2])sin(x[i+1]+x[i+2])+4x[i+1]-x[i]exp(x[i]-x[i+1])-3 == 0)\n\noptimize!(m; differentiation_backend = MadDiffAD())","category":"page"},{"location":"core/#MadDiffCore","page":"MadDiffCore","title":"MadDiffCore","text":"","category":"section"},{"location":"core/","page":"MadDiffCore","title":"MadDiffCore","text":"Modules = [MadDiffCore]","category":"page"},{"location":"core/#MadDiffCore.MadDiffCore","page":"MadDiffCore","title":"MadDiffCore.MadDiffCore","text":"MadDiffCore\n\nCore algorithm for MadDiff.\n\n\n\n\n\n","category":"module"},{"location":"core/#MadDiffCore.AbstractExpression","page":"MadDiffCore","title":"MadDiffCore.AbstractExpression","text":"AbstractExpression{T <: AbstractFloat}\n\nAbstract type for expression, gradient, hessian, entry, and field evaluators.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Constant","page":"MadDiffCore","title":"MadDiffCore.Constant","text":"Constant{T <: AbstractFloat} <: Expression{T}\n\nExpression for constants.\n\nConstant(x::T) where T <: AbstractFloat\n\nReturns a Constant with value x.\n\nExample\n\njulia> e = Constant(1.)\n1.0\njulia> non_caching_eval(e, [1.,2.,3.])\n1.0\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Constant-Union{Tuple{R}, Tuple{T}} where {T<:AbstractFloat, R<:Real}","page":"MadDiffCore","title":"MadDiffCore.Constant","text":"Constant{T}(x::R) where {T <: AbstractFloat, R <: Real}\n\nReturns a Constant{T,R} whose value is x.\n\n\n\n\n\n","category":"method"},{"location":"core/#MadDiffCore.Entry","page":"MadDiffCore","title":"MadDiffCore.Entry","text":"Entry{T <: AbstractFloat}\n\nAbstract type for entry evaluators.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Expression","page":"MadDiffCore","title":"MadDiffCore.Expression","text":"Expression{T <: AbstractFloat}\n\nAbstract type for expression evaluators.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Expression1","page":"MadDiffCore","title":"MadDiffCore.Expression1","text":"Expression1{T <: AbstractFloat, F <: Function ,E <: Expression{T}}  <: Expression{T}\n\nExpression for univariate function\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Expression2","page":"MadDiffCore","title":"MadDiffCore.Expression2","text":"Expression2{T <: AbstractFloat, F <: Function,E1, E2} <: Expression{T}\n\nExpression for bivariate function\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.ExpressionIfElse","page":"MadDiffCore","title":"MadDiffCore.ExpressionIfElse","text":"ExpressionIfElse{T,E0 <: Expression{T}, E1, E2} <: Expression{T}\n\nExpression for ifelse\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.ExpressionSum","page":"MadDiffCore","title":"MadDiffCore.ExpressionSum","text":"ExpressionSum{T <: AbstractFloat, E <: Expression{T}, I} <: Expression{T}\n\nExpression for a summation of Expressions\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Field","page":"MadDiffCore","title":"MadDiffCore.Field","text":"Field{T <: AbstractFloat}\n\nAbstract type for field evaluators.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Gradient","page":"MadDiffCore","title":"MadDiffCore.Gradient","text":"Gradient{T <: AbstractFloat}\n\nAbstract type for gradient evaluators.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Gradient-Union{Tuple{V}, Tuple{T}, Tuple{V, Tuple{Int64, Dict{Tuple{Int64, Int64}, Int64}}}} where {T, V<:Variable{T}}","page":"MadDiffCore","title":"MadDiffCore.Gradient","text":"Gradient(e :: Expression{T}) where T\n\nReturns the Gradient of an absraction e.\n\n\n\n\n\n","category":"method"},{"location":"core/#MadDiffCore.Gradient0","page":"MadDiffCore","title":"MadDiffCore.Gradient0","text":"Gradient0{T <: AbstractFloat} <: Gradient{T}\n\nGradient of Variable.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Gradient1","page":"MadDiffCore","title":"MadDiffCore.Gradient1","text":"Gradient1{T <: AbstractFloat, F, D1 <: Gradient} <: Gradient{T}\n\nGradient of Expression1.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Gradient2","page":"MadDiffCore","title":"MadDiffCore.Gradient2","text":"Gradient2{T <: AbstractFloat, F,D1 <: Gradient,D2 <: Gradient} <: Gradient{T}\n\nGradient of Expression2.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Gradient2F1","page":"MadDiffCore","title":"MadDiffCore.Gradient2F1","text":"Gradient2F1{T <: AbstractFloat, F, D1 <: Gradient, R<: Real} <: Gradient{T}\n\nGradient of Expression2 whose first argument is <: Real.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Gradient2F2","page":"MadDiffCore","title":"MadDiffCore.Gradient2F2","text":"Gradient2F2{T <: AbstractFloat, F,D1 <: Gradient, R<: Real} <: Gradient{T}\n\nGradient of Expression2 whose second argument is <: Real.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.GradientIfElse","page":"MadDiffCore","title":"MadDiffCore.GradientIfElse","text":"GradientIfElse{T, G1, G2} <: Gradient{T}\n\nGradient of ExpressionIfElse\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.GradientNull","page":"MadDiffCore","title":"MadDiffCore.GradientNull","text":"GradientNull{T <: AbstractFloat} <: Gradient{T}\n\nGradient of Parameter or Constant.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.GradientSum","page":"MadDiffCore","title":"MadDiffCore.GradientSum","text":"GradientSum{T <: AbstractFloat,D <: Gradient{T},I} <: Gradient{T}\n\nGradient of ExpressionSum.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Hessian","page":"MadDiffCore","title":"MadDiffCore.Hessian","text":"Hessian{T <: AbstractFloat}\n\nAbstract type for hessian evaluators.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Hessian02","page":"MadDiffCore","title":"MadDiffCore.Hessian02","text":"Hessian02{T,H11,H12,H21,H22} <: Hessian{T}\n\nHessian of `\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Hessian11","page":"MadDiffCore","title":"MadDiffCore.Hessian11","text":"Hessian11{T,F,H1,H11} <: Hessian{T}\n\nHessian of Expression1\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Hessian11F1","page":"MadDiffCore","title":"MadDiffCore.Hessian11F1","text":"Hessian11F1{T,F,H1,H11,R} <: Hessian{T}\n\nHessian of Expression2 whose first argument is <: Real.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Hessian11F2","page":"MadDiffCore","title":"MadDiffCore.Hessian11F2","text":"Hessian11F2{T,F,H1,H11,R} <: Hessian{T}\n\nHessian of Expression2 whose second argument is <: Real.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.HessianNull","page":"MadDiffCore","title":"MadDiffCore.HessianNull","text":"HessianNull{T} <: Hessian{T} end\n\nHessian of linear expressions (e.g., Variable, Expression2{T, typeof(*), Int64, Variable{T}} where T)\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Parameter","page":"MadDiffCore","title":"MadDiffCore.Parameter","text":"Parameter{T <: AbstractFloat} <: Expression{T}\n\nExpression for parameters.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Parameter-Tuple{Int64}","page":"MadDiffCore","title":"MadDiffCore.Parameter","text":"Parameter(n::Int)\n\nReturns a Parameter{Float64} whose index is n\n\nExample\n\njulia> e = Parameter(3)\np[3]\njulia> non_caching_eval(e, [1.,2.,3.], [4.,5.,6.])\n6.0\n\n\n\n\n\n","category":"method"},{"location":"core/#MadDiffCore.Parameter-Union{Tuple{Int64}, Tuple{T}} where T<:AbstractFloat","page":"MadDiffCore","title":"MadDiffCore.Parameter","text":"Parameter{T}(n::Int) where T <: AbstractFloat\n\nReturns a Parameter{T} whose index is n.\n\n\n\n\n\n","category":"method"},{"location":"core/#MadDiffCore.Variable","page":"MadDiffCore","title":"MadDiffCore.Variable","text":"Variable{T <: AbstractFloat} <: Expression{T}\n\nExpression for variables.\n\n\n\n\n\n","category":"type"},{"location":"core/#MadDiffCore.Variable-Tuple{Int64}","page":"MadDiffCore","title":"MadDiffCore.Variable","text":"Variable(n::Int)\n\nReturns a Variable{Float64} whose index is n\n\nExample\n\njulia> e = Variable(2)\nx[2]\njulia> non_caching_eval(e, [1.,2.,3.])\n2.0\n\n\n\n\n\n","category":"method"},{"location":"core/#MadDiffCore.Variable-Union{Tuple{Int64}, Tuple{T}} where T<:AbstractFloat","page":"MadDiffCore","title":"MadDiffCore.Variable","text":"Variable{T}(n::Int) where T <: AbstractFloat\n\nReturns a Variable{T} whose index is n.\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels","page":"MadDiffModels","title":"MadDiffModels","text":"","category":"section"},{"location":"models/","page":"MadDiffModels","title":"MadDiffModels","text":"Modules = [MadDiffModels]","category":"page"},{"location":"models/#MadDiffModels.MadDiffModels","page":"MadDiffModels","title":"MadDiffModels.MadDiffModels","text":"MadDiffModels\n\nMadDiffModels is a submodule of MadDiff. MadDiffModels allows modeling nonlinear optimization problem of the following form:\n\nminimize:   f(x)\nsubject to: xl ≤   x  ≤ xu\n            gl ≤ g(x) ≤ gu,\n\nwhere:\n\nx ∈ R^n is the decision variable.\nf : R^n -> R   is the objective function\ng : R^n -> R^m is the constraint mapping.\n\nThe model is constructed as an NLPModel (see https://github.com/JuliaSmoothOptimizers/NLPModels.jl), and can be solved with various NLP solvers such as:\n\nMadNLP (https://github.com/MadNLP/MadNLP.jl)\nIpopt (https://github.com/JuliaSmoothOptimizers/NLPModelsIpopt.jl)\nKnitro (https://github.com/JuliaSmoothOptimizers/NLPModelsKnitro.jl)\n\n\n\n\n\n","category":"module"},{"location":"models/#MadDiffModels.Constraint","page":"MadDiffModels","title":"MadDiffModels.Constraint","text":"Constraint\n\nA constraint index of MadDiffModel.\n\n\n\n\n\n","category":"type"},{"location":"models/#MadDiffModels.MadDiffModel","page":"MadDiffModels","title":"MadDiffModels.MadDiffModel","text":"MadDiffModel{T <: Real}\n\nA mathematical model of a nonlinaer program.\n\n\n\n\n\n","category":"type"},{"location":"models/#MadDiffModels.MadDiffModel-Tuple{}","page":"MadDiffModels","title":"MadDiffModels.MadDiffModel","text":"MadDiffModel()\n\nCreates an empty MadDiffModel{Float64}.\n\nExample m = MadDiffModel(linear_solver = \"ma27\")\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.MadDiffModel-Union{Tuple{}, Tuple{T}} where T","page":"MadDiffModels","title":"MadDiffModels.MadDiffModel","text":"MadDiffModel{T}()\n\nCreates an empty MadDiffModel{T}.\n\nExample m = MadDiffModel{Float32}()\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.ModelComponent","page":"MadDiffModels","title":"MadDiffModels.ModelComponent","text":"ModelComponent\n\nA model component (eitehr a variable or a parameter) of MadDiffModel.\n\n\n\n\n\n","category":"type"},{"location":"models/#MadDiffModels.constraint-Tuple{MadDiffModel, Expression}","page":"MadDiffModels","title":"MadDiffModels.constraint","text":"constraint(m::MadDiffModel, e::MadDiffCore.Expression; lb=0., ub=0.)\n\nAdds a constraint to MadDiffModel. Example ``` m = MadDiffModel()\n\nx = [variable(m) for i=1:3] constraint(m, x[1]^2 + 2*sin(x[2]) - exp(x[3]) >= 0) constraint(m, x[1]^4+ x[2]^4 x[3]^4; lb = 0.1, ub = 1.)\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.dual-Tuple{MadDiffModels.Constraint}","page":"MadDiffModels","title":"MadDiffModels.dual","text":"dual(c::Constraint)\n\nRetrun the dual of constraint c.\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.instantiate!-Tuple{MadDiffModel}","page":"MadDiffModels","title":"MadDiffModels.instantiate!","text":"instantiate!(m::MadDiffModel; sparse = true)\n\nInstantiates the model m. The model must be instantiated before solving.\n\nExample\n\nusing MadDiff, NLPModelsIpopt\n\nm = MadDiffModel() \n\nx = [variable(m) for i=1:3]\nobjective(m, x[1]^2 + x[2]^2 + sin(x[3]))\nconstraint(m, 3x[2]^2 <= 1.)\n\ninstantiate!(m)\nipopt(m)\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.lower_bound-Tuple{MadDiffModels.Constraint}","page":"MadDiffModels","title":"MadDiffModels.lower_bound","text":"lower_bound(c::Constraint)\n\nRetrun the lower bound of constraint c.\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.lower_bound-Union{Tuple{MadDiffModels.ModelComponent{V}}, Tuple{V}} where V<:Variable","page":"MadDiffModels","title":"MadDiffModels.lower_bound","text":"lower_bound(x::ModelComponent{V}) where V <: MadDiffCore.Variable\n\nRetrun the lower bound of variable x.\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.objective-Tuple{MadDiffModel, Expression}","page":"MadDiffModels","title":"MadDiffModels.objective","text":"objective(m::MadDiffModel, e::MadDiffCore.Expression\n\nSets the objective function for MadDiffModel. Only minimization is supported. Example\n\nm = MadDiffModel()\n\nx = [variable(m) for i=1:3]\nobjective(m, x[1]^2 + x[2] + sin(x[3]))\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.parameter-Union{Tuple{T}, Tuple{MadDiffModel{T}, Any}} where T","page":"MadDiffModels","title":"MadDiffModels.parameter","text":"parameter(m::MadDiffModel{T}, val)\n\nCreates a parameter for MadDiffModel with value val. Example\n\nm = MadDiffModel()\n\np = parameter(m, 0.5)\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.set_lower_bound-Tuple{MadDiffModels.Constraint, Any}","page":"MadDiffModels","title":"MadDiffModels.set_lower_bound","text":"set_lower_bound(c::Constraint,val)\n\nSet the lower bound of constraint c to val.\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.set_lower_bound-Union{Tuple{V}, Tuple{MadDiffModels.ModelComponent{V}, Any}} where V<:Variable","page":"MadDiffModels","title":"MadDiffModels.set_lower_bound","text":"set_lower_bound(x::ModelComponent{V},val) where V <: MadDiffCore.Variable\n\nSet the lower bound of variable 'x' to val.\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.set_upper_bound-Tuple{MadDiffModels.Constraint, Any}","page":"MadDiffModels","title":"MadDiffModels.set_upper_bound","text":"set_upper_bound(c::Constraint,val)\n\nSet the upper bound of constraint c to val.\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.set_upper_bound-Union{Tuple{V}, Tuple{MadDiffModels.ModelComponent{V}, Any}} where V<:Variable","page":"MadDiffModels","title":"MadDiffModels.set_upper_bound","text":"set_upper_bound(x::ModelComponent{V},val) where V <: MadDiffCore.Variable\n\nSet the upper bound of variable 'x' to val.\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.setvalue-Union{Tuple{P}, Tuple{MadDiffModels.ModelComponent{P}, Any}} where P<:Parameter","page":"MadDiffModels","title":"MadDiffModels.setvalue","text":"setvalue(p::ModelComponent{P},val) where P <: MadDiffCore.Parameter\n\nSet the value of parameter 'p' to val.\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.setvalue-Union{Tuple{V}, Tuple{MadDiffModels.ModelComponent{V}, Any}} where V<:Variable","page":"MadDiffModels","title":"MadDiffModels.setvalue","text":"setvalue(x::ModelComponent{V},val) where V <: MadDiffCore.Variable\n\nSet the value of variable 'x' to val.\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.upper_bound-Tuple{MadDiffModels.Constraint}","page":"MadDiffModels","title":"MadDiffModels.upper_bound","text":"upper_bound(c::Constraint)\n\nRetrun the upper bound of constraint c.\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.upper_bound-Union{Tuple{MadDiffModels.ModelComponent{V}}, Tuple{V}} where V<:Variable","page":"MadDiffModels","title":"MadDiffModels.upper_bound","text":"upper_bound(x::ModelComponent{V}) where V <: MadDiffCore.Variable\n\nRetrun the upper bound of variable x.\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.value-Union{Tuple{MadDiffModels.ModelComponent{P}}, Tuple{P}} where P<:Parameter","page":"MadDiffModels","title":"MadDiffModels.value","text":"value(p::ModelComponent{P}) where P <: MadDiffCore.Parameter\n\nReturn the value of parameter p.\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.value-Union{Tuple{MadDiffModels.ModelComponent{V}}, Tuple{V}} where V<:Variable","page":"MadDiffModels","title":"MadDiffModels.value","text":"value(x::ModelComponent{V}) where V <: MadDiffCore.Variable\n\nReturn the value of variable x.\n\n\n\n\n\n","category":"method"},{"location":"models/#MadDiffModels.variable-Union{Tuple{MadDiffModel{T}}, Tuple{T}} where T","page":"MadDiffModels","title":"MadDiffModels.variable","text":"variable(m::MadDiffModel{T}; lb=-Inf, ub=Inf, start=0.)\n\nCreates a variable for MadDiffModel.\n\nExample\n\nm = MadDiffModel()\n\nx = variable(m; lb = -1, ub = 1, start = 0.5)\n\n\n\n\n\n","category":"method"},{"location":"models/#NLPModels.cons!-Tuple{MadDiffModel, AbstractVector{T} where T, AbstractVector{T} where T}","page":"MadDiffModels","title":"NLPModels.cons!","text":"NLPModels.cons!(m::MadDiffModel,x::AbstractVector,y::AbstractVector)\n\nEvaluate the constraints of m at x and store the result in the vector y. \n\n\n\n\n\n","category":"method"},{"location":"models/#NLPModels.get_ifix","page":"MadDiffModels","title":"NLPModels.get_ifix","text":"get_ifix(m::MadDiffModel)\n\nReturn the value ifix from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_ifree","page":"MadDiffModels","title":"NLPModels.get_ifree","text":"get_ifree(m::MadDiffModel)\n\nReturn the value ifree from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_iinf","page":"MadDiffModels","title":"NLPModels.get_iinf","text":"get_iinf(m::MadDiffModel)\n\nReturn the value iinf from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_ilow","page":"MadDiffModels","title":"NLPModels.get_ilow","text":"get_ilow(m::MadDiffModel)\n\nReturn the value ilow from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_irng","page":"MadDiffModels","title":"NLPModels.get_irng","text":"get_irng(m::MadDiffModel)\n\nReturn the value irng from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_islp","page":"MadDiffModels","title":"NLPModels.get_islp","text":"get_islp(m::MadDiffModel)\n\nReturn the value islp from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_iupp","page":"MadDiffModels","title":"NLPModels.get_iupp","text":"get_iupp(m::MadDiffModel)\n\nReturn the value iupp from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_jfix","page":"MadDiffModels","title":"NLPModels.get_jfix","text":"get_jfix(m::MadDiffModel)\n\nReturn the value jfix from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_jfree","page":"MadDiffModels","title":"NLPModels.get_jfree","text":"get_jfree(m::MadDiffModel)\n\nReturn the value jfree from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_jinf","page":"MadDiffModels","title":"NLPModels.get_jinf","text":"get_jinf(m::MadDiffModel)\n\nReturn the value jinf from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_jlow","page":"MadDiffModels","title":"NLPModels.get_jlow","text":"get_jlow(m::MadDiffModel)\n\nReturn the value jlow from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_jrng","page":"MadDiffModels","title":"NLPModels.get_jrng","text":"get_jrng(m::MadDiffModel)\n\nReturn the value jrng from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_jupp","page":"MadDiffModels","title":"NLPModels.get_jupp","text":"get_jupp(m::MadDiffModel)\n\nReturn the value jupp from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_lcon","page":"MadDiffModels","title":"NLPModels.get_lcon","text":"get_lcon(m::MadDiffModel)\n\nReturn the value lcon from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_lin","page":"MadDiffModels","title":"NLPModels.get_lin","text":"get_lin(m::MadDiffModel)\n\nReturn the value lin from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_lin_nnzj","page":"MadDiffModels","title":"NLPModels.get_lin_nnzj","text":"get_lin_nnzj(m::MadDiffModel)\n\nReturn the value lin_nnzj from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_lvar","page":"MadDiffModels","title":"NLPModels.get_lvar","text":"get_lvar(m::MadDiffModel)\n\nReturn the value lvar from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_minimize","page":"MadDiffModels","title":"NLPModels.get_minimize","text":"get_minimize(m::MadDiffModel)\n\nReturn the value minimize from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_name","page":"MadDiffModels","title":"NLPModels.get_name","text":"get_name(m::MadDiffModel)\n\nReturn the value name from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_ncon","page":"MadDiffModels","title":"NLPModels.get_ncon","text":"get_ncon(m::MadDiffModel)\n\nReturn the value ncon from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_nlin","page":"MadDiffModels","title":"NLPModels.get_nlin","text":"get_nlin(m::MadDiffModel)\n\nReturn the value nlin from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_nln","page":"MadDiffModels","title":"NLPModels.get_nln","text":"get_nln(m::MadDiffModel)\n\nReturn the value nln from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_nln_nnzj","page":"MadDiffModels","title":"NLPModels.get_nln_nnzj","text":"get_nln_nnzj(m::MadDiffModel)\n\nReturn the value nln_nnzj from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_nlvb","page":"MadDiffModels","title":"NLPModels.get_nlvb","text":"get_nlvb(m::MadDiffModel)\n\nReturn the value nlvb from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_nlvc","page":"MadDiffModels","title":"NLPModels.get_nlvc","text":"get_nlvc(m::MadDiffModel)\n\nReturn the value nlvc from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_nlvo","page":"MadDiffModels","title":"NLPModels.get_nlvo","text":"get_nlvo(m::MadDiffModel)\n\nReturn the value nlvo from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_nnln","page":"MadDiffModels","title":"NLPModels.get_nnln","text":"get_nnln(m::MadDiffModel)\n\nReturn the value nnln from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_nnzh","page":"MadDiffModels","title":"NLPModels.get_nnzh","text":"get_nnzh(m::MadDiffModel)\n\nReturn the value nnzh from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_nnzj","page":"MadDiffModels","title":"NLPModels.get_nnzj","text":"get_nnzj(m::MadDiffModel)\n\nReturn the value nnzj from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_nnzo","page":"MadDiffModels","title":"NLPModels.get_nnzo","text":"get_nnzo(m::MadDiffModel)\n\nReturn the value nnzo from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_nvar","page":"MadDiffModels","title":"NLPModels.get_nvar","text":"get_nvar(m::MadDiffModel)\n\nReturn the value nvar from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_ucon","page":"MadDiffModels","title":"NLPModels.get_ucon","text":"get_ucon(m::MadDiffModel)\n\nReturn the value ucon from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_uvar","page":"MadDiffModels","title":"NLPModels.get_uvar","text":"get_uvar(m::MadDiffModel)\n\nReturn the value uvar from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_x0","page":"MadDiffModels","title":"NLPModels.get_x0","text":"get_x0(m::MadDiffModel)\n\nReturn the value x0 from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.get_y0","page":"MadDiffModels","title":"NLPModels.get_y0","text":"get_y0(m::MadDiffModel)\n\nReturn the value y0 from MadDiffModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#NLPModels.grad!-Tuple{MadDiffModel, AbstractVector{T} where T, AbstractVector{T} where T}","page":"MadDiffModels","title":"NLPModels.grad!","text":"NLPModels.grad!(m::MadDiffModel,x::AbstractVector,y::AbstractVector)\n\nEvaluate the gradient of m at x and store the result in the vector y.\n\n\n\n\n\n","category":"method"},{"location":"models/#NLPModels.hess_coord!-Tuple{MadDiffModel, AbstractVector{T} where T, AbstractVector{T} where T, AbstractVector{T} where T}","page":"MadDiffModels","title":"NLPModels.hess_coord!","text":"NLPModels.hess_coord!(m::MadDiffModel,x::AbstractVector,lag::AbstractVector,z::AbstractVector; obj_weight = 1.0)\n\nEvaluate the Lagrangian Hessian of m at primal x, dual lag, and objective weight obj_weight and store the result in the vector zin sparse coordinate format.\n\n\n\n\n\n","category":"method"},{"location":"models/#NLPModels.hess_structure!-Union{Tuple{T}, Tuple{MadDiffModel, AbstractVector{T}, AbstractVector{T}}} where T","page":"MadDiffModels","title":"NLPModels.hess_structure!","text":"NLPModels.hess_structure!(m::MadDiffModel,I::AbstractVector{T},J::AbstractVector{T})\n\nEvaluate the structure of the Lagrangian Hessian and store the result in I and J in sparse coordinate format.\n\n\n\n\n\n","category":"method"},{"location":"models/#NLPModels.jac_coord!-Tuple{MadDiffModel, AbstractVector{T} where T, AbstractVector{T} where T}","page":"MadDiffModels","title":"NLPModels.jac_coord!","text":"NLPModels.jac_coord!(m::MadDiffModel,x::AbstractVector,J::AbstractVector)\n\nEvaluate the constraints Jacobian of m at x and store the result in the vector J in sparse coordinate format.\n\n\n\n\n\n","category":"method"},{"location":"models/#NLPModels.jac_structure!-Union{Tuple{T}, Tuple{MadDiffModel, AbstractVector{T}, AbstractVector{T}}} where T","page":"MadDiffModels","title":"NLPModels.jac_structure!","text":"NLPModels.jac_structure!(m::MadDiffModel,I::AbstractVector{T},J::AbstractVector{T})\n\nEvaluate the structure of the constraints Jacobian and store the result in I and J in sparse coordinate format.\n\n\n\n\n\n","category":"method"},{"location":"models/#NLPModels.obj-Tuple{MadDiffModel, AbstractVector{T} where T}","page":"MadDiffModels","title":"NLPModels.obj","text":"NLPModels.obj(m::MadDiffModel,x::AbstractVector)\n\nReturn the objective value of m at x.\n\n\n\n\n\n","category":"method"},{"location":"moi/#MadDiffMOI","page":"MadDiffMOI","title":"MadDiffMOI","text":"","category":"section"},{"location":"moi/","page":"MadDiffMOI","title":"MadDiffMOI","text":"Modules = [MadDiffMOI]","category":"page"},{"location":"moi/#MadDiffMOI.MadDiffMOI","page":"MadDiffMOI","title":"MadDiffMOI.MadDiffMOI","text":"MadDiffMOI\n\nMadDiffMOI is a submodule of MadDiff. MadDifMOI allows solving nonlinear optimization problems specified by MathOptInterface (https://github.com/jump-dev/JuMP.jl/tree/od/moi-nonlinear).\n\n\n\n\n\n","category":"module"},{"location":"moi/#MadDiffCore.Expression-Tuple{MathOptInterface.Nonlinear.Expression}","page":"MadDiffMOI","title":"MadDiffCore.Expression","text":"Expression(ex::MOI.Nonlinear.Expression; subex = nothing)\n\nCreate a MadDiff.Expression from MOI.Expression.\n\n\n\n\n\n","category":"method"},{"location":"moi/#MadDiffCore.SparseNLPCore-Tuple{MathOptInterface.Nonlinear.Model}","page":"MadDiffMOI","title":"MadDiffCore.SparseNLPCore","text":"MadDiffCore.SparseNLPCore(nlp_data::MOI.Nonlinear.Model)\n\nCreate MadDiffCore.SparseNLPCore from MOI.Nonlinear.Model.\n\n\n\n\n\n","category":"method"},{"location":"moi/#MadDiffMOI.MadDiffAD","page":"MadDiffMOI","title":"MadDiffMOI.MadDiffAD","text":"MadDiffAD() <: MOI.Nonlinear.AbstractAutomaticDifferentiation\n\nA differentiation backend for MathOptInterface based on MadDiff\n\n\n\n\n\n","category":"type"},{"location":"moi/#MadDiffMOI.MadDiffEvaluator","page":"MadDiffMOI","title":"MadDiffMOI.MadDiffEvaluator","text":"MadDiffEvaluator <: MOI.AbstractNLPEvaluator\n\nA type for callbacks for MathOptInterface's nonlinear model.\n\n\n\n\n\n","category":"type"},{"location":"moi/#MathOptInterface.NLPBlockData-Tuple{MadDiffMOI.MadDiffEvaluator}","page":"MadDiffMOI","title":"MathOptInterface.NLPBlockData","text":"MOI.NLPBlockData(evaluator::MadDiffEvaluator)\n\nCreate MOI.NLPBlockData from MadDiffEvaluator\n\n\n\n\n\n","category":"method"},{"location":"moi/#MathOptInterface.Nonlinear.Evaluator-Tuple{MathOptInterface.Nonlinear.Model, MadDiffAD, Vector{MathOptInterface.VariableIndex}}","page":"MadDiffMOI","title":"MathOptInterface.Nonlinear.Evaluator","text":"MOI.Nonlinear.Evaluator(model::MOI.Nonlinear.Model, ::MadDiffAD, ::Vector{MOI.VariableIndex})\n\nCreate a MOI.Nonlinear.Evaluator from MOI.Nonlinear.Model using MadDiff's AD capability.\n\n\n\n\n\n","category":"method"},{"location":"moi/#MathOptInterface.eval_constraint-Tuple{MadDiffMOI.MadDiffEvaluator, Any, Any}","page":"MadDiffMOI","title":"MathOptInterface.eval_constraint","text":"MOI.eval_constraint(evaluator::MadDiffEvaluator, g, x)\n\nEvaluate the gradient of evaluator at x and store the result in the vector g.\n\n\n\n\n\n","category":"method"},{"location":"moi/#MathOptInterface.eval_constraint_jacobian-Tuple{MadDiffMOI.MadDiffEvaluator, Any, Any}","page":"MadDiffMOI","title":"MathOptInterface.eval_constraint_jacobian","text":"MOI.eval_constraint_jacobian(evaluator::MadDiffEvaluator, J, x)\n\nEvaluate the constraints Jacobian of evaluator at x and store the result in the vector J in sparse coordinate format.\n\n\n\n\n\n","category":"method"},{"location":"moi/#MathOptInterface.eval_hessian_lagrangian-Tuple{MadDiffMOI.MadDiffEvaluator, Any, Any, Any, Any}","page":"MadDiffMOI","title":"MathOptInterface.eval_hessian_lagrangian","text":"MOI.eval_hessian_lagrangian(evaluator::MadDiffEvaluator, H, x, σ, μ)\n\nEvaluate the Lagrangian Hessian of evaluator at primal x, dual μ, and objective weight σ and store the result in the vector H in sparse coordinate format.\n\n\n\n\n\n","category":"method"},{"location":"moi/#MathOptInterface.eval_objective-Tuple{MadDiffMOI.MadDiffEvaluator, Any}","page":"MadDiffMOI","title":"MathOptInterface.eval_objective","text":"MOI.eval_objective(evaluator::MadDiffEvaluator, x)\n\nReturn the objective value of evaluator at x.\n\n\n\n\n\n","category":"method"},{"location":"moi/#MathOptInterface.eval_objective_gradient-Tuple{MadDiffMOI.MadDiffEvaluator, Any, Any}","page":"MadDiffMOI","title":"MathOptInterface.eval_objective_gradient","text":"MOI.eval_objective_gradient(evaluator::MadDiffEvaluator, g, x)\n\nEvaluate the constraints of evaluator at x and store the result in the vector g. \n\n\n\n\n\n","category":"method"},{"location":"moi/#MathOptInterface.hessian_lagrangian_structure-Tuple{MadDiffMOI.MadDiffEvaluator}","page":"MadDiffMOI","title":"MathOptInterface.hessian_lagrangian_structure","text":"MOI.hessian_lagrangian_structure(evaluator::MadDiffEvaluator)\n\nReturn the structure of the Lagrangian Hessian in Vector{Tuple{Int,Int}} format.\n\n\n\n\n\n","category":"method"},{"location":"moi/#MathOptInterface.jacobian_structure-Tuple{MadDiffMOI.MadDiffEvaluator}","page":"MadDiffMOI","title":"MathOptInterface.jacobian_structure","text":"MOI.jacobian_structure(evaluator::MadDiffEvaluator)\n\nReturn the structure of the constraints Jacobian in Vector{Tuple{Int,Int}} format.\n\n\n\n\n\n","category":"method"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Welcome to the documentation of MadDiff.jl","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nThis documentation page is under construction.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nThis documentation is also available in PDF format.","category":"page"},{"location":"#What-is-MadDiff?","page":"Introduction","title":"What is MadDiff?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"MadDiff.jl is a simple algebraic modeling/differentiation package. MadDiff.jl constructs first and second derivative functions off-line (i.e., prior to calling the optimization solver) by applying operator overloading-based automatic differentiation on functions. The exact derivative functions can be obtained as results. ","category":"page"},{"location":"#Bug-reports-and-support","page":"Introduction","title":"Bug reports and support","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Please report issues and feature requests via the Github issue tracker. ","category":"page"}]
}
